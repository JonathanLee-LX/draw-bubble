<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style type="text/css">
        .container {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 800px;
            height: 500px;
            transform: translate(-50%, -50%);
            border: 1px solid #aaa;
            cursor: crosshair;
            background-image: url(1.jpg);
            background-size: cover;
        }

        #frame{
            font-size: 24px;
            color: aquamarine;
        }
    </style>
</head>

<body>
    <span id="frame"></span>
    <div class="container">
        <canvas id="drawing" width="800px" height="500px"></canvas>
    </div>
    <script type="text/javascript">
        var a = 0 //记录图片是否载入，载入后a++
        var start, FRAME;
        var frame = document.getElementById('frame')


        var img1 = new Image();
        img1.src = './红泡.png';
        img1.onload = function () {
            a++
            if (a == 2) {
                start = Date.now();
                window.requestAnimationFrame(run)
            }
        }

        var img2 = new Image();
        img2.src = './蓝泡.png';
        img2.onload = function () {
            a++
            if (a == 2) {
                start = Date.now();
                window.requestAnimationFrame(run)
            }

        }

        var WIDTH = 800,
            HEIGHT = 500;

        var canvas = document.getElementById('drawing')
        var ctx = canvas.getContext('2d');

        var mouse = {
            x: 400,
            y: 250
        }



        canvas.onmousemove = function (e) {
            mouse.x = e.offsetX
            mouse.y = e.offsetY
        }

        canvas.onmouseleave = function (e) {
            mouse.x = -1
            mouse.y = -1
        }

        var num = 100 //气泡数量-1
        var bot = []
        for (var i = 0; i < num; i++) {
            bot[i] = new Bot()
        }

        bot[num] = new Bot()
        bot[num].x = 300
        bot[num].y = 100
        bot[num].r = 70
        bot[num].speedx = 1
        bot[num].speedy = 1
        bot[num].state = 0
        bot[num].img = img1



        function Bot() { //类构造函数，用来封装气泡图片
            this.x = (Math.random() * 800) + 20 //气泡x方向位置随机值
            this.y = (Math.random() * 500) + 20 //气泡y方向位置随机值
            this.r = (Math.random() * 20) + 60 //气泡半径随机值
            this.speedx = (Math.random() * 2) + 1 //气泡x方向速度随机值
            this.speedy = (Math.random() * 1) + 1 //气泡y方向速度随机值
            //气泡移动方向，1为右下，2为右上，3为左上，4为左下
            this.state = Math.floor((Math.random() * 3)) + 1
            this.img = img2 //载入图像，使用到两种颜色的气泡图像，img1为红色，img2为蓝色
        }


        //气泡绘制
        function draw(x, y, r) {
            ctx.lineWidth = 1
            ctx.strokeStyle = 'rgba(255, 255, 255, .3)'
            ctx.beginPath()
            ctx.arc(x, y, r, 0, 2 * Math.PI)
            ctx.closePath()
            ctx.stroke()
        }

        //气泡移动
        function move(bot) {
            if (bot.state == 1) { //右下
                bot.x += bot.speedx
                bot.y += bot.speedy
            } else if (bot.state == 2) { //右上
                bot.x += bot.speedx
                bot.y -= bot.speedy
            } else if (bot.state == 3) { //左上
                bot.x -= bot.speedx
                bot.y -= bot.speedy
            } else if (bot.state == 4) { //左下
                bot.x -= bot.speedx
                bot.y += bot.speedy
            } else if (bot.state == 0) {
                bot.x += bot.speedx
                bot.y += bot.speedy
            }

            // //定义气泡超出边界的行为
            if (bot.x - bot.r >= WIDTH) {
                bot.x = 0
            }
            if (bot.x + bot.r <= 0) {
                bot.x = WIDTH
            }
            if (bot.y - bot.r >= HEIGHT) {
                bot.y = 0
            }
            if (bot.y + bot.r <= 0) {
                bot.y = HEIGHT
            }

            //画图像，位置和大小由bot来决定，这样图像可以跟随bot一起运动

            isCollision();
            followMouse();

            draw(bot.x + bot.r, bot.y + bot.r, bot.r) //画圆圈，方便碰撞检测
            ctx.drawImage(bot.img, bot.x, bot.y, 2 * bot.r, 2 * bot.r)
        }

        // 获取鼠标指针的位置
        function followMouse() {
            if (mouse.x < 0 && mouse.y < 0) {
                return
            }
            var red = bot[bot.length - 1]
            red.x = mouse.x - red.r
            red.y = mouse.y - red.r
            if (red.x > WIDTH - 2 * red.r) {
                red.x = WIDTH - 2 * red.r
            } else if (red.x < 0) {
                red.x = 0
            }
            if (red.y > HEIGHT - 2 * red.r) {
                red.y = HEIGHT - 2 * red.r
            } else if (red.y < 0) {
                red.y = 0;
            }
        }

        // 检测是否碰撞
        function isCollision() {
            var red = bot[bot.length - 1];
            red.center = {
                x: red.x + red.r,
                y: red.y + red.r
            }
            var blue, d, offset = {};
            for (var i = 0; i < bot.length - 1; i++) {
                blue = bot[i]
                blue.center = {
                    x: blue.x + blue.r,
                    y: blue.y + blue.r
                }
                // 获取红泡和蓝泡之间的相对位置
                offset.x = red.center.x - blue.center.x;
                offset.y = red.center.y - blue.center.y;


                d = Math.sqrt(Math.pow(offset.x, 2) + Math.pow(offset.y, 2));

                if (d < red.r + blue.r) {
                    if (offset.x > 0 && offset.y > 0) {
                        // 左上方
                        blue.state = 3
                        blue.x = blue.x <= (red.center.x - (Math.abs(offset.x) + blue.r)) ? blue.x : red.center.x - (
                            Math.abs(offset.x) + blue.r)
                        blue.y = blue.y <= (red.center.y - (Math.abs(offset.y) + blue.r)) ? blue.y : red.center.y - (
                            Math.abs(offset.y) + blue.r)
                    } else if (offset.x > 0 && offset.y < 0) {
                        // 左下方
                        blue.state = 4
                        blue.x = blue.x <= (red.center.x - (Math.abs(offset.x) + blue.r)) ? blue.x : red.center.x - (
                            Math.abs(offset.x) + blue.r)
                        blue.y = blue.y <= (red.center.y + (Math.abs(offset.y) + blue.r)) ? blue.y : red.center.y + (
                            Math.abs(offset.y) + blue.r)

                    } else if (offset.x < 0 && offset.y > 0) {
                        // 右上方
                        blue.state = 2
                        blue.x = blue.x >= (red.center.x + (Math.abs(offset.x) - blue.r)) ? blue.x : red.center.x + (
                            Math.abs(offset.x) + blue.r)
                        blue.y = blue.y <= (red.center.y - (Math.abs(offset.y) + blue.r)) ? blue.y : red.center.y - (
                            Math.abs(offset.y) + blue.r)
                    } else {
                        // 右下方
                        blue.state = 1
                        blue.x = blue.x >= (red.center.x + (Math.abs(offset.x) - blue.r)) ? blue.x : red.center.x + (
                            Math.abs(offset.x) - blue.r)
                        blue.y = blue.y >= (red.center.y + (Math.abs(offset.y) - blue.r)) ? blue.y : red.center.y + (
                            Math.abs(offset.y) - blue.r)
                    }
                }
            }
        }

        function blue() {
            for (var i = 0; i < bot.length - 1; i++) {

            }
        }


        function run() {
            for (var i = 0; i < bot.length; i++) {
                // boon(bot[i]) //红色气泡和蓝色气泡的交互
                // blue() //蓝色气泡之间的交互
                move(bot[i])
            }
            setTimeout('ctx.clearRect(0,0,800,500)', 1000 / 80)
            time = Date.now() - start
            FRAME = Math.floor(1000/time)
            start = Date.now()
            window.requestAnimationFrame(run)
        }

        function showFrame(){
            frame.innerText = FRAME
            setTimeout(showFrame, 500)
        }

        setTimeout(showFrame, 500)
    </script>
</body>

</html>